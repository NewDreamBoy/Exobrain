# C# 浅拷贝与深拷贝笔记整理

---

## 🌊 浅拷贝（Shallow Copy）

**定义：**

浅拷贝会创建一个新对象，然后将当前对象的非静态字段复制到新对象中。

- 如果字段是 **值类型**（如 `int`, `float`, `struct`），则复制**值本身**。
- 如果字段是 **引用类型**（如 `class`, `string`, `array`），则只复制**引用（内存地址）**，而不复制引用的对象本身。

**结果：**

新对象和原对象中的引用类型字段指向内存中的**同一个对象**。修改其中一个对象的引用类型属性，会影响另一个。

**实现方式：**

C# 提供了 `Object.MemberwiseClone()` 方法来实现浅拷贝。

**图解：**

假设有一个对象 A，里面有一个 `int` 和一个指向对象 B 的引用。

- **浅拷贝后：** 产生对象 A_Copy。
    - `int` 被复制了一份。
    - 引用仍然指向同一个对象 B。

**代码示例：**

```csharp
public class Person
{
    public int Age; // 值类型
    public Address Addr; // 引用类型

    public Person ShallowCopy()
    {
        return (Person)this.MemberwiseClone();
    }
}

public class Address
{
    public string City;
}

// 测试
Person p1 = new Person();
p1.Age = 10;
p1.Addr = new Address { City = "Beijing" };

Person p2 = p1.ShallowCopy();

// 修改 p2
p2.Age = 20;            // p1.Age 不会变，因为 int 是值类型
p2.Addr.City = "Tokyo"; // p1.Addr.City 也会变成 "Tokyo"！因为它们指向同一个 Address 对象
```

---

## 🏊‍♂️ 深拷贝（Deep Copy）

**定义：**

深拷贝不仅复制对象本身，还会递归地复制该对象所引用的**所有**对象。

- 它会创建一个全新的对象图。
- 原对象和新对象之间没有任何共享的引用（除了不可变类型如 string 或 null）。

**结果：**

新对象和原对象是**完全独立**的。修改任何一个对象的任何属性，永远不会影响另一个。

**实现方式：**

C# 没有内置通用的深拷贝方法，通常需要自己实现：

1. **序列化/反序列化（最常用）**：将对象转为 JSON/XML/二进制流，再转回来。
2. **手动实现**：手动创建新对象并逐个赋值。
3. **反射**：编写通用代码递归复制。

**图解：**

- **深拷贝后：** 产生对象 A_Copy。
    - `int` 被复制。
    - 它不再指向原来的对象 B，而是创建了一个新的对象 B_Copy，并指向它。

**代码示例：**

```csharp
using Newtonsoft.Json; // 假设使用 JSON 库

public class Person
{
    public int Age;
    public Address Addr;

    public Person DeepCopy()
    {
        // 方法1：序列化法（简单但性能稍低）
        string json = JsonConvert.SerializeObject(this);
        return JsonConvert.DeserializeObject<Person>(json);

        // 方法2：手动创建（繁琐但性能高）
        // Person newP = new Person();
        // newP.Age = this.Age;
        // newP.Addr = new Address { City = this.Addr.City };
        // return newP;
    }
}

// 测试
Person p1 = new Person();
p1.Age = 10;
p1.Addr = new Address { City = "Beijing" };

Person p2 = p1.DeepCopy();

p2.Addr.City = "Tokyo"; 
// 此时 p1.Addr.City 仍然是 "Beijing"，互不干扰
```

---